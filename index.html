<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>异步寻宝动画</title>
<style>
  :root{
    --bg:#0b0f1a;
    --panel:#121a2b;
    --accent:#f6c453;
    --text:#eaf1ff;
    --muted:#9fb0cc;
    --danger:#ff5c7a;
    --success:#64d38a;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background: radial-gradient(1200px 600px at 70% 0%, #10182a, var(--bg));
    color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Noto Sans CJK SC", "Microsoft YaHei", Arial, sans-serif;
  }
  .wrap{
    display:grid;
    grid-template-columns: 1.2fr 1fr;
    gap:16px;
    padding:16px;
    max-width:1100px;
    margin:0 auto;
  }
  @media (max-width: 800px){
    .wrap{grid-template-columns:1fr}
  }

  /* 场景舞台 */
  .stage{
    position:relative;
    background: linear-gradient(#0f1526 55%, #0b0f1a);
    border:1px solid #20304e;
    border-radius:12px;
    overflow:hidden;
    min-height:420px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  .sky{
    position:absolute; inset:0 0 50% 0;
    background: radial-gradient(600px 300px at 60% -10%, #1b2a4a, transparent), linear-gradient(#0f1a31, #0d1527);
  }
  .ground{
    position:absolute; inset:50% 0 0 0;
    background: repeating-linear-gradient(90deg, #0d1526 0 40px, #0a1120 40px 80px);
  }
  /* 星星 */
  .star{position:absolute; width:2px; height:2px; background:#fff; opacity:.8; border-radius:50%;}
  /* 角色 */
  .hero{
    --x: 10%;
    position:absolute; bottom:18%; left:var(--x);
    width:46px; height:46px; border-radius:8px;
    background: linear-gradient(145deg, #3da1ff, #1a5fb4);
    box-shadow: 0 6px 18px rgba(61,161,255,.35);
    display:grid; place-items:center;
    transform: translateY(0);
    transition: left .8s ease, transform .25s ease;
  }
  .hero::after{
    content:"🔦";
    filter: drop-shadow(0 0 8px rgba(246,196,83,.8));
    transform: translateX(6px);
  }
  /* 火把光锥 */
  .cone{
    position:absolute; bottom:28%; left:calc(var(--x) + 26px);
    width:0; height:0; border-left: 140px solid rgba(246,196,83,.18);
    border-top: 40px solid transparent;
    border-bottom: 40px solid transparent;
    filter: blur(2px);
    transition:left .8s ease;
  }
  /* 守卫 */
  .guard{
    position:absolute; bottom:18%; left:64%;
    width:44px; height:44px; border-radius:50%;
    background: linear-gradient(145deg, #e0586b, #7c1e2c);
    box-shadow: 0 6px 18px rgba(224,88,107,.35);
    display:grid; place-items:center;
  }
  .guard::after{content:"🛡️"}
  /* 机关门 */
  .door{
    position:absolute; bottom:15%; left:40%;
    width:36px; height:80px;
    background: linear-gradient(#7a6a3a, #4a3e1e);
    border:2px solid #bfa15a; border-radius:6px;
    transform-origin:left center; transform: perspective(200px) rotateY(0deg);
    transition: transform .6s ease;
  }
  .door.open{ transform: perspective(200px) rotateY(-60deg); }
  /* 箱子 */
  .chest{
    position:absolute; bottom:16%; left:78%;
    width:56px; height:36px; border-radius:6px;
    background: linear-gradient(#9c5324, #5a2e12);
    border:2px solid #d89a52;
    display:grid; place-items:center;
  }
  .chest::after{content:"📦"}
  .chest.glow{ box-shadow: 0 0 24px 8px rgba(246,196,83,.35) inset, 0 0 18px rgba(246,196,83,.4); }

  /* 日志面板 */
  .panel{
    background: var(--panel);
    border:1px solid #20304e;
    border-radius:12px;
    padding:14px;
    min-height:420px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    display:flex; flex-direction:column;
  }
  .title{font-weight:700; font-size:18px; margin-bottom:8px}
  .log{
    flex:1; overflow:auto; padding:8px; background:rgba(10,16,30,.6);
    border-radius:8px; border:1px solid #1e2a44;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    line-height:1.4; color:var(--muted);
  }
  .log p{margin:.25rem 0}
  .log p.ok{color:var(--success)}
  .log p.err{color:var(--danger)}
  .controls{
    display:flex; gap:8px; margin-top:10px; flex-wrap:wrap
  }
  button{
    background:linear-gradient(180deg, #1a2b4b, #13213a);
    color:var(--text); border:1px solid #28416e; border-radius:8px;
    padding:10px 14px; cursor:pointer; font-weight:600;
  }
  button:hover{filter:brightness(1.08)}
  button:disabled{opacity:.6; cursor:not-allowed}

  /* 提示条 */
  .toast{
    position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
    background:#0f1b32; color:var(--text); border:1px solid #28416e;
    padding:10px 14px; border-radius:8px; opacity:0; pointer-events:none;
    transition: opacity .3s ease, transform .3s ease;
  }
  .toast.show{opacity:1; transform:translateX(-50%) translateY(-8px)}
</style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <div class="sky"></div>
      <div class="ground"></div>

      <!-- 随机星星 -->
      <div id="stars"></div>

      <div class="hero" id="hero"></div>
      <div class="cone" id="cone"></div>
      <div class="door" id="door"></div>
      <div class="guard" id="guard"></div>
      <div class="chest" id="chest"></div>
    </div>

    <div class="panel">
      <div class="title">异步寻宝任务</div>
      <div class="log" id="log"></div>
      <div class="controls">
        <button id="run">开始寻宝</button>
        <button id="retry" disabled>重试</button>
        <button id="skipRand">关闭随机失败</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">就绪</div>

<script>
/* 工具函数 */
const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));
const logBox = document.getElementById('log');
const toast = document.getElementById('toast');
function log(msg, type){
  const p = document.createElement('p');
  p.textContent = msg;
  if(type==='ok') p.classList.add('ok');
  if(type==='err') p.classList.add('err');
  logBox.appendChild(p);
  logBox.scrollTop = logBox.scrollHeight;
}
function tip(msg){
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(()=>toast.classList.remove('show'), 1400);
}

/* 星星生成 */
(function makeStars(){
  const stars = document.getElementById('stars');
  for(let i=0;i<90;i++){
    const s = document.createElement('div');
    s.className = 'star';
    s.style.left = Math.random()*100 + '%';
    s.style.top = Math.random()*45 + '%';
    s.style.opacity = (0.4 + Math.random()*0.6).toFixed(2);
    s.style.transform = `scale(${0.6 + Math.random()*1.4})`;
    stars.appendChild(s);
  }
})();

/* 角色与场景元素 */
const hero = document.getElementById('hero');
const cone = document.getElementById('cone');
const door = document.getElementById('door');
const guard = document.getElementById('guard');
const chest = document.getElementById('chest');

function moveHeroTo(percent){
  hero.style.setProperty('--x', percent + '%');
  cone.style.left = `calc(${percent}% + 26px)`;
}

/* 原始API与新增情节（与上节一致，但为页面独立实现） */
class TreasureMap {
  static getInitialClue(){
    return new Promise(res=>setTimeout(()=>res("在古老的图书馆里找到了第一个线索..."), 800));
  }
  static decodeAncientScript(clue){
    return new Promise((res, rej)=>setTimeout(()=>{
      if(!clue) return rej("没有线索可以解码!");
      res("解码成功!宝藏在一座古老的神庙中...");
    }, 1000));
  }
  static searchTemple(location){
    return new Promise((res, rej)=>setTimeout(()=>{
      const random = Math.random();
      if(randomFail && random < 0.5) return rej("糟糕!遇到了神庙守卫!");
      res("找到了一个神秘的箱子...");
    }, 1200));
  }
  static openTreasureBox(){
    return new Promise(res=>setTimeout(()=>res("恭喜!你找到了传说中的宝藏!"), 800));
  }
}
class Adventure {
  static consultHistorian(){
    return new Promise(res=>setTimeout(()=>res("历史学家提供了坐标与避开陷阱的小贴士。"), 700 + Math.random()*400));
  }
  static solveRiddleDoor(){
    return new Promise((res, rej)=>setTimeout(()=>{
      const ok = !randomFail || Math.random() > 0.2;
      if(!ok) return rej("机关门谜题太复杂，解答失败。");
      res("机关门发出咔哒声，缓缓开启。");
    }, 900));
  }
  static stealthPastGuards(hasTip=true){
    return new Promise((res, rej)=>setTimeout(()=>{
      const base = hasTip ? 0.8 : 0.55;
      const ok = !randomFail || Math.random() < base;
      if(!ok) return rej("被守卫发现了！只好暂避锋芒。");
      res("你趁火把转角时悄然通过。");
    }, 900));
  }
  static disarmTrap(){
    return new Promise((res, rej)=>setTimeout(()=>{
      const ok = !randomFail || Math.random() > 0.15;
      if(!ok) return rej("触发了机关，箱子被再次上锁！");
      res("成功解除箱子上的毒针陷阱。");
    }, 1000));
  }
  static appraiseTreasure(){
    return new Promise(res=>setTimeout(()=>{
      const real = Math.random() > 0.3;
      res(real ? "鉴定结果：真品！" : "鉴定结果：赝品，不过也很精美。");
    }, 700));
  }
  static celebrate(result){
    return new Promise(res=>setTimeout(()=>res(`篝火晚会庆祝：${result}`), 600));
  }
}

let running = false;
let randomFail = true;

async function animateStep(toPercent){
  moveHeroTo(toPercent);
  await sleep(600);
}

async function runQuest(){
  if(running) return;
  running = true;
  document.getElementById('run').disabled = true;
  document.getElementById('retry').disabled = true;
  logBox.innerHTML = "";
  door.classList.remove('open');
  chest.classList.remove('glow');
  tip("任务开始");
  try{
    log("出发！");
    await animateStep(18);

    const clue = await TreasureMap.getInitialClue();
    log(clue, 'ok');

    const tipFromHist = await Adventure.consultHistorian();
    log(tipFromHist, 'ok');

    await animateStep(36);

    const location = await TreasureMap.decodeAncientScript(clue);
    log(location, 'ok');

    log("尝试解开机关门的谜题...");
    try{
      const doorMsg = await Adventure.solveRiddleDoor();
      door.classList.add('open');
      log(doorMsg, 'ok');
    }catch(e){
      log(e, 'err');
      log("使用历史学家的提示再次尝试...",);
      const doorMsg = await Adventure.solveRiddleDoor();
      door.classList.add('open');
      log(doorMsg, 'ok');
    }

    await animateStep(48);

    // 潜行两次机会
    let passed = false;
    for(let i=0;i<2 && !passed;i++){
      try{
        const msg = await Adventure.stealthPastGuards(true);
        log(msg, 'ok');
        passed = true;
      }catch(e){
        log(e, 'err');
        log("观察守卫动向，准备再试一次...");
        await sleep(700);
      }
    }
    if(!passed) throw new Error("多次尝试仍未绕过守卫，先撤退。");

    await animateStep(64);

    const box = await TreasureMap.searchTemple(location);
    log(box, 'ok');

    const disarm = await Adventure.disarmTrap();
    log(disarm, 'ok');

    await animateStep(78);

    const treasure = await TreasureMap.openTreasureBox();
    chest.classList.add('glow');
    log(treasure, 'ok');

    const appraisal = await Adventure.appraiseTreasure();
    log(appraisal, appraisal.includes("真品") ? 'ok' : undefined);

    const finale = await Adventure.celebrate(appraisal.includes("真品") ? "举杯同庆！" : "虽是赝品，也不虚此行。");
    log(finale, 'ok');
    tip("任务完成！");
  }catch(err){
    log(`任务失败: ${err}`, 'err');
    tip("任务失败");
  } finally {
    running = false;
    document.getElementById('run').disabled = false;
    document.getElementById('retry').disabled = false;
  }
}

/* 事件绑定 */
document.getElementById('run').addEventListener('click', runQuest);
document.getElementById('retry').addEventListener('click', runQuest);
document.getElementById('skipRand').addEventListener('click', (e)=>{
  randomFail = !randomFail;
  e.target.textContent = randomFail ? "关闭随机失败" : "开启随机失败";
  tip(randomFail ? "已开启随机事件" : "已关闭随机事件（更易成功）");
});
</script>
</body>
</html>